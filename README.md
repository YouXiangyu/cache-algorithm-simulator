# CAPSA - 缓存算法性能模拟器与分析器

- 创建/更新时间：2025-01-21

## 简介

CAPSA 是一个轻量级缓存性能模拟器，用于在相同的访问序列上比较 ARC、LRU、LFU、FIFO、2Q 和理论最优 OPT 算法。所有内置负载由 `capsa/trace_suite.py` 使用基于函数的脚本动态生成，无需预生成的跟踪文件。

## 核心特性

- **固定缓存大小**：32 页
- **固定请求数**：每个负载 50000 次请求
- **9 个内置负载**：3 个有利于 LFU，3 个有利于 LRU，3 个其他（SCAN/ADAPT）
- **两种使用模式**：带数字参数的命令行或交互式 CLI 菜单
- **动态生成**：所有负载实时生成，保证可重现性

## 系统要求

- Python 3.10+

## 快速启动

### 安装

无需安装，直接使用：

```bash
# 克隆或下载项目后，直接运行
python main.py
```

### 运行示例

```bash
# 方式1：交互式菜单（推荐）
python main.py

# 方式2：命令行参数
python main.py -1          # 运行负载 1
python main.py -1 -3 -5    # 运行负载 1、3 和 5
python main.py -9          # 运行负载 9

# 生成跟踪文件（可选）
python generate_fixed_traces.py
```

交互式菜单将显示所有 9 个负载及其特征，您可以：
- 输入用空格或逗号分隔的负载编号（例如，`1 3 5` 或 `1,3,5`）
- 按 Enter 运行所有负载
- 选择多个负载进行批量分析

## 核心组件

### 主要文件

#### `main.py`
主入口点，提供命令行接口。支持两种模式：
- **数字参数模式**：使用 `-1`, `-2` 等参数直接指定负载
- **交互式菜单模式**：不带参数运行，显示所有负载供选择

主要功能：
- 解析命令行参数或显示交互菜单
- 调用 `trace_suite.py` 生成负载序列
- 使用 `simulator.py` 运行模拟
- 使用 `metrics.py` 生成性能报告

#### `generate_fixed_traces.py`
可选工具，将动态生成的负载序列导出为文本文件。生成的 `.trace` 文件保存在 `traces/` 目录中，可用于外部分析或调试。

### 核心模块（`capsa/`）

#### `cache_base.py`
定义统一的缓存接口 `Cache` 抽象基类。所有缓存算法必须实现：
- `access(page_id: int) -> bool`：访问页面，返回命中（True）或未命中（False）
- `get_stats() -> Dict[str, int]`：返回内部统计信息（如命中/未命中计数）

这确保了所有算法具有统一的接口，便于在相同条件下进行比较。

#### `capsa/caches/`
包含 6 种缓存算法的独立实现：
- **`lru.py`**：最近最少使用（LRU）算法，基于 `OrderedDict` 实现 O(1) 操作
- **`lfu.py`**：最不常用（LFU）算法，按访问频率和 LRU 共同淘汰
- **`fifo.py`**：先进先出（FIFO）算法，使用队列实现
- **`arc.py`**：自适应替换缓存（ARC），实现自适应的 LRU/LFU 混合策略
- **`two_q.py`**：2Q 双队列算法，利用 FIFO 热身队列与 LRU 主队列结合
- **`opt.py`**：理论最优（OPT）算法，需要预知未来访问序列

每个实现都是独立的，可以单独测试和优化。

#### `simulator.py`
模拟器核心，负责执行模拟过程：
- `Simulator` 类：顺序读取跟踪序列，将每个页面访问传递给缓存算法
- `SimulationResult` 数据类：记录模拟结果，包括命中率、未命中数、执行时间等
- 使用 `time.perf_counter_ns()` 测量算法开销（非实际 I/O 时间）

#### `metrics.py`
性能指标收集器和报告生成器：
- `MetricsCollector` 类：将 `SimulationResult` 转换为人类可读的报告
- `ReportConfig` 数据类：配置报告格式和内容
- 生成包含命中率排名、运行时间排名等信息的详细报告

#### `trace_suite.py`
负载定义和生成模块，这是项目的核心：
- 定义 9 个固定负载的生成函数
- 每个负载使用函数式编程方式生成，保证可重现性
- `TraceRecipe` 数据类：描述每个负载的元数据（键、文件名、类别、目标等）
- `repeat_function()`：辅助函数，用于重复执行某个函数
- `trim_to_target()`：辅助函数，确保生成的序列长度恰好为 50000

## 9 种负载详解

### 有利于 LFU 的负载（1-3）

#### WL01_HOT10_80_20：热/冷模式

**代码原理**：
```python
def hot() -> None:
    seq.extend(range(1, 19))  # 18 个热页

def cold() -> None:
    seq.extend(range(19, 51))  # 32 个冷页

# 每轮：8×hot + 2×cold = 8×18 + 2×32 = 208 次请求
# 重复 240 轮，总计约 50000 次请求
```

**特性**：
- 强频率偏向：80% 的访问集中在 18 个热页（1-18）
- 20% 的访问分散在 32 个冷页（19-50）
- 热集（18 页）小于缓存（32 页），但产生竞争压力

**最适合算法**：**LFU**
- 频率信息比最近使用信息更重要
- LFU 能够识别并保留频繁访问的热页
- LRU 可能因为冷页的偶尔访问而错误地保留它们

#### WL02_HOT20_60_40：扩展热集

**代码原理**：
```python
def hot() -> None:
    seq.extend(range(1, 21))  # 20 个热页

def warm() -> None:
    seq.extend(range(21, 61))  # 40 个温页

# 每轮：7×hot + 3×warm = 7×20 + 3×40 = 260 次请求
# 重复 192 轮
```

**特性**：
- 70% 的访问集中在 20 个热页（1-20）
- 30% 的访问分散在 40 个温页（21-60）
- 热集大小（20 页）接近缓存大小（32 页），测试频率与空间的平衡

**最适合算法**：**LFU**
- 热集和温集的访问频率差异明显
- LFU 能够根据频率正确区分热页和温页
- LRU 可能因为温页的最近访问而错误地保留它们

#### WL03_EHOT2_90_10：极端热点

**代码原理**：
```python
def hot_pair() -> None:
    seq.extend([1, 2] * 45)  # 90 次访问：1,2,1,2,...

def background() -> None:
    seq.extend(range(3, 51))  # 48 次访问：3,4,5,...,50

# 每轮：8×hot_pair + 2×background = 8×90 + 2×48 = 816 次请求
# 重复 61 轮
```

**特性**：
- 极端频率偏向：85% 的访问集中在仅 2 个页面（1 和 2）
- 15% 的访问作为背景噪声分散在 48 个页面（3-50）
- 测试算法在极端频率偏向场景下的表现

**最适合算法**：**LFU**
- 频率信息极其重要，页面 1 和 2 的访问频率远高于其他页面
- LFU 能够识别并始终保留这两个热点页面
- LRU 可能因为背景噪声的最近访问而错误地驱逐热点页面

### 有利于 LRU 的负载（4-6）

#### WL04_SW32：滑动窗口（匹配缓存）

**代码原理**：
```python
# 使用滑动窗口生成函数
_generate_sliding_window(
    window_size=32,      # 窗口大小 = 缓存大小
    step_size=1,         # 每次滑动 1 个位置
    max_page=500,        # 页面范围 1..500（循环）
    target_requests=50000
)

# 生成模式：窗口 [1..32], [2..33], [3..34], ...
```

**特性**：
- 纯最近使用模式：工作集以滑动窗口形式连续移动
- 窗口大小（32）恰好匹配缓存大小（32）
- 无频率信息：每个页面在窗口内只访问一次，然后被新页面替换

**最适合算法**：**LRU**
- 最近使用信息比频率信息更重要
- LRU 能够完美跟踪滑动窗口，始终保留最近访问的 32 个页面
- LFU 无法利用频率信息（每个页面频率相同），表现较差

#### WL05_SW40：更大滑动窗口

**代码原理**：
```python
_generate_sliding_window(
    window_size=40,      # 窗口大小 > 缓存大小
    step_size=1,
    max_page=600,
    target_requests=50000
)
```

**特性**：
- 窗口大小（40）大于缓存大小（32），产生驱逐压力
- 缓存无法容纳整个工作集
- 测试 LRU 处理大于缓存的工作集的能力

**最适合算法**：**LRU**
- 虽然无法完全容纳工作集，但 LRU 能够保留最近访问的页面
- 窗口移动速度较慢（步长 1），LRU 能够跟上变化
- LFU 仍然无法利用频率信息

#### WL06_SW32_STEP2：快速滑动窗口

**代码原理**：
```python
_generate_sliding_window(
    window_size=32,
    step_size=4,         # 每次滑动 4 个位置（更快）
    max_page=500,
    target_requests=50000
)

# 生成模式：窗口 [1..32], [5..36], [9..40], ...
```

**特性**：
- 窗口移动速度更快（步长 4 vs 步长 1）
- 窗口大小匹配缓存，但移动更快
- 测试缓存跟踪快速变化的工作集的能力

**最适合算法**：**LRU**
- 虽然移动更快，但仍然是最近使用模式
- LRU 能够跟踪快速移动的工作集
- 更快的移动使得缓存更难跟上，但 LRU 仍然是最佳选择

### 其他负载（7-9）

#### WL07_HOT20_SCAN48000：热集 + 扫描

**代码原理**：
```python
def hot() -> None:
    seq.extend(range(1, 21))  # 20 个热页

def long_scan() -> None:
    seq.extend(range(1, 20_001))  # 20000 页顺序扫描

# 阶段1：750×hot = 15000 次请求（建立热集）
# 阶段2：1×long_scan = 20000 次请求（扫描刷新缓存）
# 阶段3：750×hot = 15000 次请求（测试恢复能力）
```

**特性**：
- 三阶段模式：热集建立 → 顺序扫描 → 热集恢复
- 顺序扫描会刷新缓存，但热集随后恢复
- 测试算法的扫描抗性和恢复能力

**最适合算法**：**2Q**
- 2Q 算法设计用于处理扫描模式
- 使用 FIFO 热身队列（A1in）过滤一次性访问（扫描）
- 热集页面在扫描后能够快速恢复到主队列（Am）
- LRU/LFU 会被扫描完全刷新，恢复较慢

#### WL08_SCAN_SANDWICH：扫描-热三明治

**代码原理**：
```python
hot_set = list(range(1, 21))  # 20 个热页

# 阶段1：扫描 1..15000（15000 次请求）
# 阶段2：热集 50 轮（1000 次请求）
# 阶段3：扫描 15001..30000（15000 次请求）
# 阶段4：热集 400 轮（8000 次请求）
# 阶段5：扫描 30001..41000（11000 次请求）
```

**特性**：
- 扫描和热阶段交替出现（三明治模式）
- 热集被扫描"夹在中间"
- 测试重复刷新后的缓存恢复能力
- 更平衡：扫描和热阶段交替，不像 WL07 那样极端

**最适合算法**：**2Q**
- 2Q 能够区分一次性访问（扫描）和重复访问（热集）
- 扫描不会污染主队列，热集能够快速恢复
- LRU/LFU 会被每次扫描刷新，无法有效保留热集

#### WL09_AB_HOT_SW32：交替热/滑动窗口

**代码原理**：
```python
def phase_a() -> None:
    """热阶段：8 轮热页 + 冷页跳跃"""
    for _ in range(8):
        seq.extend(range(1, 11))  # 8×10 = 80 次请求
    seq.extend([11 + (30 * k % 990) for k in range(20)])  # 20 次冷页
    # 总计：100 次请求

def phase_b(step_idx: int) -> None:
    """滑动窗口阶段：32 个连续页面"""
    start = 1 + (step_idx * 7 % (500 - 32))
    seq.extend(range(start, start + 32))  # 32 次请求

# 每轮：phase_a + phase_b = 100 + 32 = 132 次请求
# 重复 378 轮
```

**特性**：
- 两种模式交替：频率偏向（phase A）和最近使用偏向（phase B）
- Phase A：80% 访问集中在 10 个热页，20% 分散访问
- Phase B：滑动窗口模式，32 个连续页面
- 测试算法的自适应性

**最适合算法**：**ARC**
- ARC 是自适应算法，能够在 LRU 和 LFU 之间切换
- Phase A 时，ARC 倾向于 LFU 模式（频率重要）
- Phase B 时，ARC 倾向于 LRU 模式（最近使用重要）
- ARC 能够根据访问模式自动调整策略参数 `p`
- 其他算法只能固定策略，无法适应变化

## 负载对比表

| # | 键 | 类别 | 核心特征 | 最适合算法 | 关键测试点 |
|---|-----|----------|----------------|------------|------------|
| 1 | WL01_HOT10_80_20 | LFU | 80% 访问 18 个热页 | LFU | 频率偏向 |
| 2 | WL02_HOT20_60_40 | LFU | 70% 访问 20 个热页 | LFU | 频率与空间平衡 |
| 3 | WL03_EHOT2_90_10 | LFU | 85% 访问 2 个页面 | LFU | 极端频率偏向 |
| 4 | WL04_SW32 | LRU | 滑动窗口 32（匹配缓存） | LRU | 最近使用模式 |
| 5 | WL05_SW40 | LRU | 滑动窗口 40（大于缓存） | LRU | 工作集压力 |
| 6 | WL06_SW32_STEP2 | LRU | 快速滑动窗口（步长 4） | LRU | 快速变化跟踪 |
| 7 | WL07_HOT20_SCAN48000 | SCAN | 热集 + 长扫描 | 2Q | 扫描抗性 |
| 8 | WL08_SCAN_SANDWICH | SCAN | 扫描-热交替模式 | 2Q | 重复刷新恢复 |
| 9 | WL09_AB_HOT_SW32 | ADAPT | 热/滑动窗口交替 | ARC | 自适应能力 |

## 注意事项

- 所有负载都是动态生成的，不需要预生成的跟踪文件
- 所有模拟的缓存大小固定为 32 页
- 每个负载生成恰好 50000 次请求
- LRU 负载中的窗口大小调整为匹配或略超过缓存大小 32
- 代码注释为中文，但 CLI 交互信息保持英文
