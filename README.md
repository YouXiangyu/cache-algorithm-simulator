# CAPSA - 缓存算法性能模拟器与分析器

- 创建/更新时间：2025-01-21

CAPSA 是一个轻量级缓存性能模拟器，用于在相同的访问序列上比较 ARC、LRU、LFU、FIFO、2Q 和理论最优 OPT 算法。所有内置负载由 `capsa/trace_suite.py` 使用基于函数的脚本动态生成。

## 核心特性

- **固定缓存大小**：32 页
- **固定请求数**：每个负载 50000 次请求
- **9 个负载**：3 个有利于 LFU，3 个有利于 LRU，3 个其他（SCAN/ADAPT）
- **两种使用模式**：带数字参数的命令行或交互式 CLI 菜单

## 核心组件

- `capsa/cache_base.py`：统一的缓存接口，所有策略实现 `access()` / `get_stats()`。
- `capsa/caches/`：ARC/LRU/LFU/FIFO/2Q/OPT 算法的独立实现。
- `capsa/simulator.py`：顺序执行跟踪序列，收集命中率和模拟时间。
- `capsa/metrics.py`：将 `SimulationResult` 转换为人类可读的报告。
- `capsa/trace_suite.py`：定义 9 个固定负载，每个都是基于函数的脚本。
- `generate_fixed_traces.py`：如果需要，将生成的跟踪序列导出为文本文件。
- `main.py`：带 CLI 支持的主入口点。

## 系统要求

- Python 3.10+

## 使用方法

### 模式 1：数字参数

使用数字参数运行特定负载：

```bash
python main.py -1          # 运行负载 1
python main.py -1 -3 -5    # 运行负载 1、3 和 5
python main.py -9          # 运行负载 9
```

### 模式 2：交互式 CLI 菜单

不带参数运行以查看交互式菜单：

```bash
python main.py
```

菜单将显示所有 9 个负载及其特征。您可以：
- 输入用空格或逗号分隔的负载编号（例如，`1 3 5` 或 `1,3,5`）
- 按 Enter 运行所有负载
- 选择多个负载进行批量分析

### 示例

```bash
# 交互式菜单
python main.py

# 运行特定负载
python main.py -1
python main.py -1 -2 -3

# 运行所有负载（通过交互式菜单，按 Enter）
python main.py

# 生成跟踪文件（可选）
python generate_fixed_traces.py
```

## 目录结构

```
capsa/
  cache_base.py
  caches/
  metrics.py
  simulator.py
  trace_suite.py       # 负载定义和生成逻辑
docs/
  trace_suite_design.md
generate_fixed_traces.py
main.py
traces/                # （可选）导出的静态跟踪文件
```

## 内置负载

所有负载生成恰好 50000 次请求并使用缓存大小 32。

| # | 键 | 类别 | 特征 | 更适合 |
|---|-----|----------|----------------|------------|
| 1 | WL01_HOT10_80_20 | LFU | 80% 访问 10 个热页，20% 访问冷页 | LFU |
| 2 | WL02_HOT20_60_40 | LFU | 60% 访问 20 个热页，40% 访问温页 | LFU |
| 3 | WL03_EHOT2_90_10 | LFU | 极端 90% 访问 2 个页面 | LFU |
| 4 | WL04_SW32 | LRU | 滑动窗口大小 32（匹配缓存） | LRU |
| 5 | WL05_SW40 | LRU | 滑动窗口大小 40（略大于缓存） | LRU |
| 6 | WL06_SW32_STEP2 | LRU | 滑动窗口 32，步长 2（更快移动） | LRU |
| 7 | WL07_HOT20_SCAN48000 | SCAN | 热集 + 长顺序扫描 | 2Q |
| 8 | WL08_SCAN_SANDWICH | SCAN | 扫描-热-扫描-热三明治模式 | 2Q |
| 9 | WL09_AB_HOT_SW32 | ADAPT | 交替的热阶段和滑动窗口阶段 | ARC |

## 负载详情

### 有利于 LFU 的负载（1-3）

- **WL01_HOT10_80_20**：函数 A 访问 1..18（热），函数 B 访问 19..50（冷）。调度：每 10 次调用中 8×A + 2×B。
- **WL02_HOT20_60_40**：函数 A 访问 1..20（热），函数 B 访问 21..60（温）。调度：每 10 次调用中 7×A + 3×B。
- **WL03_EHOT2_90_10**：函数 A 在页面 1 和 2 之间交替（90 次访问），函数 B 访问 3..50（48 次访问）。调度：8×A -> 2×B。

### 有利于 LRU 的负载（4-6）

- **WL04_SW32**：单个函数，滑动窗口大小 32，每次向右滑动 1 个位置。
- **WL05_SW40**：单个函数，滑动窗口大小 40（略大于缓存 32），产生压力。
- **WL06_SW32_STEP2**：单个函数，滑动窗口大小 32，步长 4（更快移动）。

### 其他负载（7-9）

- **WL07_HOT20_SCAN48000**：热集 1..20，然后顺序扫描 1..20000，然后再次热集。测试扫描抗性。
- **WL08_SCAN_SANDWICH**：扫描 1..15000，热集 50 轮，扫描 15001..30000，热集 400 轮，扫描 30001..41000。测试缓存恢复。
- **WL09_AB_HOT_SW32**：阶段 A（热 1..10）和阶段 B（滑动窗口 32）交替。测试 ARC 自适应性。

## 负载改进建议

基于测试结果，以下是负载的分类和改进建议：

### ✅ **良好（保持现状）**

- **WL04**：LFU 表现明显较差（7% vs 96%），对比度优秀
- **WL05**：2Q 显示明显优势（54% vs 0%），优秀
- **WL09**：LFU 显示明显优势（73% vs 54%），良好

### ⚠️ **需要小幅调整**

- **WL02**：将热比例从 60% 增加到 70%（已实现）
- **WL03**：将背景噪声从 10% 增加到 15-20%（已实现）
- **WL06**：将步长从 2 增加到 4-5（已实现为 4）

### ❌ **需要重大修复**

- **WL01**：所有算法 99.94% - 无差异化
  - **问题**：10 个热页对于 32 页缓存来说太小
  - **解决方案**：将热集扩展到 15-18 页或降低热访问比例（已实现：扩展到 18 页）
  
- **WL07**：所有算法 4% - 扫描太长
  - **问题**：48000 页扫描完全刷新缓存
  - **解决方案**：将扫描减少到 15000-20000 页（已实现：减少到 20000 页）
  
- **WL08**：所有算法 50% - 热阶段过于占主导
  - **问题**：1200 轮热阶段（24000 次请求）占主导
  - **解决方案**：减少到 300-400 轮（已实现：减少到 400 轮）

### 负载定位说明

每个负载的设计目标如下：

1. **WL01-WL03（LFU 有利）**：测试频率偏向场景，其中某些页面被频繁访问，频率信息比最近使用信息更重要。

2. **WL04-WL06（LRU 有利）**：测试最近使用偏向场景，其中工作集以滑动窗口模式移动，最近使用信息比频率信息更重要。

3. **WL07-WL08（SCAN 模式，2Q 有利）**：测试扫描抗性场景，其中顺序扫描会刷新缓存，但热集随后恢复。2Q 算法设计用于处理此类模式。

4. **WL09（ADAPT 模式，ARC 有利）**：测试自适应场景，其中访问模式在频率偏向和最近使用偏向之间交替。ARC 算法应能适应并切换策略。

## 注意事项

- 所有负载都是动态生成的，不需要预生成的跟踪文件。
- 所有模拟的缓存大小固定为 32 页。
- 每个负载生成恰好 50000 次请求。
- LRU 负载中的窗口大小调整为匹配或略超过缓存大小 32。
